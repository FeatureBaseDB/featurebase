package txprefix

func TestBadger_KeyPrefix(t *testing.T) {

	// txprefix.Prefix() must agree with txprefix.Key(), but not have the key at the end.
	// This is important for iteration over containers.

	index, field, view, shard := "i", "f", "v", uint64(0)

	// needle examples with the container-key extremes:
	// "index:'i';field:'f';view:'v';shard:'0';key@00000000000000000000" // smallest
	// "index:'i';field:'f';view:'v';shard:'0';key@18446744073709551615" // largest
	needle := txprefix.Key(index, field, view, shard, 0)

	// prefix example: "index:'i';field:'f';view:'v';shard:'0';key@"
	prefix := txprefix.Prefix(index, field, view, shard)

	if !bytes.HasPrefix(needle, prefix) {
		panic(fmt.Sprintf("txprefix.Prefix() output '%v'was not a prefix of txprefix.Key() '%v'", string(needle), string(prefix)))
	}
	if len(prefix)+20 != len(needle) {
		panic(fmt.Sprintf("txprefix.Prefix() output '%v'was 20 characters shorter than txprefix.Key() '%v'", string(needle), string(prefix)))
	}

	// validate assumption that txprefix.KeyExtractContainerKey() makes about strconv.ParseUint() error reporting;
	// for distinguishing prefixes from full keys. Even if the shard number is so large that the prefix
	// starts with a legitimate decimal number.
	shouldNotParse := "12345123451234';key@"
	containerKey, err := strconv.ParseUint(shouldNotParse, 10, 64)
	if err == nil {
		panic(fmt.Sprintf("strconv.ParseUint should have returned an error parsing this string '%v'; instead we got '%v'", shouldNotParse, containerKey))
	}

	// verify panic on submitting a prefix
	func() {
		defer func() {
			r := recover()
			if r == nil {
				panic(fmt.Sprintf("should have seen panic on call to txprefix.KeyExtractContainerKey(prefix='%v')", prefix))
			}
		}()
		txprefix.KeyExtractContainerKey(prefix) // should panic.
	}()
}
